
-- local variables
local z
local dark_color               = vmath.vector4(.18, .20, .22, 1)
local detector_highlight_color = vmath.vector4(1,1,4,1)

-- local functions:
local mark_as_detector, tile_tint, animate_tile




function init(self)
	local x, y

	go.set_scale(.5)
	sprite.set_hflip("#sprite", math.random(1,2) == 2)
	sprite.set_vflip("#sprite", math.random(1,2) == 2)
	msg.post("#collide_tile", "disable")
	msg.post("#collide_wave", "enable")

	if theme_data[current_theme][2] == 1 then
		if theme_data[current_theme][4] == nil then
			sprite.play_flipbook("#sprite", "tile"..current_theme)
		else
			sprite.play_flipbook("#sprite", "tile"..current_theme.."_ON")
		end
	else
		sprite.play_flipbook("#sprite", "tile"..current_theme.."_"..math.random(1, theme_data[current_theme][2]))
	end

	local data = theme_data[current_theme][3]
	if data ~= nil then
		if data == 1 then
			local angle = math.random(1, 2) >= 2 and 90 or 0
			go.set(".", "euler.z", angle)
		else
			go.set(".", "euler.z", math.random(0,360))
		end
	end

	self.pos          = go.get_position()
	self.rot          = go.get(".", "euler.z")
	self.scale        = go.get_scale()

	x, y = gen_offscreen_pos(100)

	go.set_position(vmath.vector3(x, y, 1))
	go.set(".", "euler.z", math.random(0, 360))
	go.set_scale(math.random(2, 62) / 10)

	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, self.pos, go.EASING_OUTQUINT, math.random(6, 12) / 10)
	go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, self.rot, go.EASING_OUTQUINT, 1)
	go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTQUINT, .4, 0, function()
		go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, self.scale / 2, go.EASING_INQUINT, .6, 0, function()
			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTQUINT, math.random(1, 8))
			tile_tint(0, .2)
			animate_tile(self, false)
		end)
	end)
end




function on_message(self, message_id, message, sender)
	if message.group == hash("tile") then
		local pos = go.get_position()
		msg.post("#collide_tile", "disable")
		pos.z = z
		z = z + 0.001
		go.set_position(pos)




	elseif message.group == hash("wave") and message_id == hash("contact_point_response") then
		local max_angle, max_blast_range = 140, 635
		local pos1 = go.get_position()
		local pos2 = go.get_position(message.other_id)
		local rot = go.get(".", "euler.z")

		local distance_temp = math.sqrt( (pos1.x - pos2.x)^2 + (pos1.y - pos2.y)^2 )
		local distance      = distance_temp / max_blast_range
		distance = math.max(0, math.min(distance, 1))
		local angle = max_angle * (1.01 - distance)
		local pos = pos1 + message.normal * (message.distance * (4.62 * (1.12 - distance)))
		rot = vmath.quat_rotation_z((rot + math.random(-angle, angle)) * math.pi / 180)

		--print("dist: "..distance_temp.."    dist_range: "..distance.."    angle: "..angle)

		go.cancel_animations(".", "euler")
		go.cancel_animations(".", "scale")
		local rotate_time = .6 * (1 - distance)
		local r_min = (rotate_time - rotate_time / 20) * 100
		local r_max = (rotate_time + rotate_time / 20) * 100
		go.animate(".", "rotation", go.PLAYBACK_ONCE_FORWARD, rot, go.EASING_OUTSINE, math.random(r_min, r_max) / 100)
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_OUTSINE, .32, 0, function()
			msg.post("#collide_tile", "enable")
		end)
		msg.post("#collide_wave", "disable")




	elseif message_id == hash("reveal tile") then
		local pos = go.get_position()

		tile_tint(1, .44)

		if message.detector then
			go.cancel_animations(".", "scale")
			go.set_scale(self.scale)
			mark_as_detector()
			pos.z = pos.z + 0.12
		else
			pos.z = pos.z + 0.1
		end

		go.cancel_animations(".", "position")
		go.set_position(vmath.vector3(pos.x, pos.y, pos.z))
		animate_tile(self, true)

		local id = factory.create("/main#tile_reveal_particle_factory", vmath.vector3(0))
		go.set_parent(id, message.parent)
		table.insert(tile_particles_table, id)
		particlefx.play(msg.url(nil, id, "tile_reveal"..message.type))




	elseif message_id == hash("add highlight") then
		local color = vmath.vector4(detector_highlight_color)
		color.z = color.z * theme_data[current_theme][5]
		go.animate("#sprite", "tint", go.PLAYBACK_LOOP_PINGPONG, color, go.EASING_INOUTSINE, .8)

	elseif message_id == hash("remove highlight") then
		tile_tint(message.type)




	elseif message_id == hash("set Z") then
		z = 0.1

	elseif message_id == hash("delete") then
		go.delete()
	end
end




function mark_as_detector()
	go.cancel_animations("#sprite", "tint")
	sprite.set_constant("#sprite", "tint", vmath.vector4(.25, .4, 2.2, 1))
	local scale = go.get_scale().x + .1
	go.animate(".", "scale", go.PLAYBACK_LOOP_PINGPONG, vmath.vector3(scale), go.EASING_INOUTSINE, 1)
end




-- type:
-- 0 - unrevealed
-- 1 - revealed
function tile_tint(type, anim_time)
	local anim_time = anim_time or 1

	if type == 0 then
		if theme_data[current_theme][4] == nil then
			go.animate("#sprite", "tint", go.PLAYBACK_ONCE_FORWARD, dark_color, go.EASING_INOUTSINE, anim_time)
		else
			go.animate("#sprite", "tint", go.PLAYBACK_ONCE_FORWARD, vmath.vector4(1), go.EASING_INOUTSINE, anim_time)
			sprite.play_flipbook("#sprite", "tile"..current_theme.."_OFF")
		end
	else
		go.animate("#sprite", "tint", go.PLAYBACK_ONCE_FORWARD, vmath.vector4(1), go.EASING_INOUTSINE, anim_time)
		if theme_data[current_theme][4] ~= nil then
			sprite.play_flipbook("#sprite", "tile"..current_theme.."_ON")
		end
	end
end




function animate_tile(self, refresh_z)
	local pos = vmath.vector3(self.pos)
	local distance = 2

	pos.x = pos.x + math.random(-distance, distance)
	pos.y = pos.y + math.random(-distance, distance)
	pos.z = refresh_z and go.get_position().z or pos.z
	self.pos = vmath.vector3(self.pos.x, self.pos.y, pos.z)

	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_INOUTSINE, math.random(2, 4), 0, function()
		animate_tile(self, false)
	end)
end
