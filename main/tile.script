
go.property("x", 0)
go.property("y", 0)




function init(self)
	local x, y
	go.set_scale(.5)
	sprite.set_hflip("#tile_main", math.random(1,2) == 2)
	sprite.set_vflip("#tile_main", math.random(1,2) == 2)

	if theme_data[current_theme][2] == 1 then
		if theme_data[current_theme][5] == nil then
			sprite.play_flipbook("#tile_main", "tile"..current_theme)
		else
			sprite.play_flipbook("#tile_main", "tile"..current_theme.."_ON")
		end
	else
		sprite.play_flipbook("#tile_main", "tile"..current_theme.."_"..math.random(1, theme_data[current_theme][2]))
	end

	if theme_data[current_theme][4] ~= nil then
		sprite.set_constant("#tile_border", "tint", vmath.vector4(0,0,0,1))
	else
		sprite.set_constant("#tile_border", "tint", vmath.vector4(0,0,0,0))
	end

	if theme_data[current_theme][3] ~= nil then
		go.set(".", "euler.z", math.random(0,360))
	end
		

	self.pos     = go.get_position()
	self.rot     = go.get(".", "euler.z")
	self.scale   = go.get_scale()
	self.collide = true

	--if self.gen_new_pos then
		x, y = gen_offscreen_pos(100)
	--else
		--x, y = self.pos.x, self.pos.y
	--end

	go.set_position(vmath.vector3(x, y, 1))
	go.set(".", "euler.z", math.random(0, 360))
	go.set_scale(math.random(2, 62) / 10)

	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, self.pos, go.EASING_OUTQUINT, math.random(6, 12) / 10)
	go.animate(".", "euler.z", go.PLAYBACK_ONCE_FORWARD, self.rot, go.EASING_OUTQUINT, math.random(1, 2))
	go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTQUINT, .4, 0, function()
		go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, self.scale / 2, go.EASING_INQUINT, .6, 0, function()
			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, self.scale, go.EASING_OUTQUINT, .4)
			if theme_data[current_theme][5] == nil then
				sprite.set_constant("#tile_main", "tint", vmath.vector4(.2, .22, .24, 1))
			else
				sprite.play_flipbook("#tile_main", "tile"..current_theme.."_OFF")
			end
		end)
	end)
end




function on_message(self, message_id, message, sender)
	local id

	if message.group == hash("touch") then
		msg.post(message.other_id, "disable collider")
		check_clicked_tile(tile_num_x, tile_num_y)


	elseif message.group == hash("wave") and message_id == hash("contact_point_response") and self.collide == true then
		local pos = go.get_position() + message.normal * (message.distance * 1.4)
		local rot = vmath.quat_rotation_z((math.random(-90, 90) * math.pi / 180))
		self.collide = false
		go.set_position(pos) ; go.set_rotation(rot)
		msg.post("/main#level", "tile sync", {x = self.x, y = self.y, pos = pos, rot = rot})


	elseif message_id == hash("reveal tile") then
		if theme_data[current_theme][5] == nil then
			sprite.set_constant("#tile_main", "tint", vmath.vector4(1,1,1,1))
		else
			sprite.play_flipbook("#tile_main", "tile"..current_theme.."_ON")
		end
		id = factory.create("/main#tile_reveal_particle_factory")
		msg.post(id, "play particles", {type = message.type})


	elseif message_id == hash("delete") then
		go.delete()
	end
end
