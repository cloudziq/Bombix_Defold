
-- tile status:
-- 0: unrevealed
-- 1: revealed
-- 2: contains a bomb

local board_data = {}  --[tile_x][tile_y][ [tile_id, digit_id, marker_id, bomb_id], tile_status, bomb_counter]


local tile_size  = 64   -- in pixels
local tiles_left, markers
local x_def, y_def
local allow_board_input, allow_gui_input = false, false


local board_tiles_x = level_data[current_level][1]
local board_tiles_y = level_data[current_level][2]
local bombs_amount = 0
for i = 1, current_level do
	bombs_amount  = bombs_amount + level_data[i][3]
end


-- local functions:
local tile_marker, reveal_tiles, game_over, prepare_board, reset_board, gen_num, gen_pos




function init(self)
	msg.post(".", "acquire_input_focus")
	math.randomseed(socket.gettime())
	prepare_board()

	for a = 1, 8 do
		factory.create("/main#BG_factory")
		--table.insert(BG_table, id)
		--BG_url = msg.url(nil, id, nil)
	end
end




function update(self, dt)
	if self.check_input then
		if socket.gettime() >= hold_time then
			self.check_input = false
			tile_marker(tile_num_x, tile_num_y)
		end
	end
end




function on_input(self, action_id, action)
	local allow_click = true

	if allow_board_input then
		if action_id ~= nil and action.pressed then
			tile_num_x = math.ceil((action.x - (window_w - (board_tiles_x * tile_size)) / 2) / tile_size)
			tile_num_y = math.ceil((action.y - (window_h - (board_tiles_y * tile_size)) / 2) / tile_size)
			if tile_num_x < 1 or tile_num_x > board_tiles_x or tile_num_y < 1 or tile_num_y > board_tiles_y then
				allow_click = false
			end
		end

		if allow_click then
			if action_id == hash("touch") then
				if action.pressed then
					hold_time = socket.gettime() + .44
					self.check_input = true
				elseif action.released and self.check_input then
					self.check_input = false
					if board_data[tile_num_x][tile_num_y][1][3] == 0 then
						factory.create("#touch_factory", vmath.vector3(action.x, action.y, 1))
					end
				end

			elseif action_id == hash("mark") and action.pressed then
				tile_marker(tile_num_x, tile_num_y)
			end
		end
	end
end




function on_message(self, message_id, message)
	if message_id == hash("restart") and allow_gui_input then
		allow_board_input = false
		allow_gui_input = false
		--timer.delay(.2, false, function()
			reset_board()
		--end)
	end
end




function tile_marker(x, y)
	local id = board_data[x][y][1][3]
	local cx = ((window_w - (board_tiles_x * tile_size)) / 2) + ((x - 1) * tile_size) + (tile_size / 2)
	local cy = ((window_h - (board_tiles_y * tile_size)) / 2) + ((y - 1) * tile_size) + (tile_size / 2)

	if board_data[x][y][2] ~= 1 then
		if id == 0 then
			markers = markers + 1
			local id = factory.create("#tile_marker_factory", vmath.vector3(cx, cy, .99))
			board_data[x][y][1][3] = id
			sound.play("/sound#tile_mark", {speed = 1.8})
		else
			markers = markers - 1
			msg.post(id, "delete")
			board_data[x][y][1][3] = 0
			sound.play("/sound#tile_mark", {speed = 3.4})
		end
	end

	msg.post("/gui#level", "update display", {type = "marker", amount = markers})
end




function check_clicked_tile(x, y)
	if allow_board_input then
		local tile = board_data[x][y][2]

		if tile == 0 then
			reveal_sound_allow = true
			reveal_tiles(x, y, {})
			sound.play("/sound#plumk", {gain = .4, speed = math.random(80, 120) / 100} )
		elseif tile >= 2 then
			msg.post(board_data[x][y][1][4], "detonate bomb")
			game_over()
		end
	end
end




local near_coords = {{-1, -1}, {0, -1}, {1, -1}, {-1, 0}, {1, 0}, {-1, 1}, {0, 1}, {1, 1}}

function reveal_tiles(x, y, neighbours_table, count)
	local cx, cy, particle_type
	count = count or 0

	board_data[x][y][2] = 1
	tiles_left = tiles_left - 1
	msg.post("/gui#level", "update display", {type = "tile", amount = tiles_left})

	if tiles_left == 0 then print("YOU WIN!") end

	if reveal_sound_allow and count > 0 then
		reveal_sound_allow = false
		sound.play("/sound#droplet")
		sound.play("/sound#reveal")
	end

	for index, value in ipairs(near_coords) do
		cx = x + value[1]
		cy = y + value[2]

		if (cx >= 1 and cx <= board_tiles_x) and (cy >= 1 and cy <= board_tiles_y) then
			if board_data[x][y][3] == 0 then
				local tile = board_data[cx][cy][2]

				if board_data[x][y][3] == 0 and board_data[cx][cy][2] < 2 then
					table.insert(neighbours_table, {cx, cy})
				end
			else
				msg.post(board_data[x][y][1][2], "reveal digit")
			end
		end
	end

	if #neighbours_table == 0 then
		particle_type = ""
	else
		-- process neighbours:
		for index, _ in ipairs(neighbours_table) do
			local x = neighbours_table[index][1]
			local y = neighbours_table[index][2]
			-- process only unrevealed tiles
			if board_data[x][y][2] == 0 then
				reveal_tiles(x, y, neighbours_table, count + 1)
			end
		end
		particle_type = "_multi"
	end

	-- remove markers
	if board_data[x][y][1][3] ~= 0 then
		msg.post(board_data[x][y][1][3], "delete")
		board_data[x][y][1][3] = 0
		markers = markers - 1
	end

	msg.post(board_data[x][y][1][1], "reveal tile", {type = particle_type})
end




function game_over()
	local x, y

	for x = 1, board_tiles_x do
		for y = 1, board_tiles_y do
			if board_data[x][y][2] == 2 then
				msg.post(board_data[x][y][1][4], "reveal bomb")
			end
		end
	end

	allow_board_input = false
	print("RIP")
end




function prepare_board()
	local x_def = ((window_w - (board_tiles_x * tile_size)) / 2) + (tile_size / 2)
	local y_def = ((window_h - (board_tiles_y * tile_size)) / 2) + (tile_size / 2)
	local x, y, cx, cy = x_def, y_def, bomb

	tiles_left = (board_tiles_x * board_tiles_y) - bombs_amount
	markers = 0

	for a = 1, board_tiles_x do
		table.insert(board_data, {})
		for b = 1, board_tiles_y do
			local id = factory.create("#tile_factory", vmath.vector3(x, y, .5))
			board_data[a][b] = {{id, 0, 0, 0}, 0, 0}
			y = y + tile_size
		end
		y = y_def
		x = x + tile_size
	end


	-- generate bombs:
	x, y = gen_pos()
	for bomb = 1, bombs_amount do
		while board_data[x][y][2] == 2 do x, y = gen_pos() end
		board_data[x][y][2] = 2
		cx = x_def + ((x - 1) * tile_size)
		cy = y_def + ((y - 1) * tile_size)
		local id = factory.create("#bomb_factory", vmath.vector3(cx, cy + 4, 1))
		board_data[x][y][1][4] = id
	end


	-- generate numbers:
	for x = 1, board_tiles_x do
		for y = 1, board_tiles_y do
			gen_num(x, y)
		end
	end

	timer.delay(1, false, function()
		msg.post("/gui#level", "show display", {bombs = bombs_amount, tiles = tiles_left})
		allow_board_input = true
		allow_gui_input = true
	end)
end




function gen_num(x, y)
	local counter, cx, cy = 0

	for index, _ in ipairs(near_coords) do
		cx = x + near_coords[index][1]
		cy = y + near_coords[index][2]

		if (cx >= 1 and cx <= board_tiles_x) and (cy >= 1 and cy <= board_tiles_y) then
			if board_data[cx][cy][2] == 2 then
				counter = counter + 1
			end
		end
	end

	if counter > 0 then
		cx = ((window_w - (board_tiles_x * tile_size)) / 2) + ((x - 1) * tile_size)
		cy = ((window_h - (board_tiles_y * tile_size)) / 2) + ((y - 1) * tile_size)
		local id = factory.create("/main#counter_factory", vmath.vector3(cx, cy, 0))
		label.set_text(msg.url(nil, id, "label"), tostring(counter))
		board_data[x][y][1][2] = id
	end

	board_data[x][y][3] = counter
end




function gen_pos()
	local x, y = math.random(1, board_tiles_x), math.random(1, board_tiles_y)
	return x, y
end




function reset_board()
	local x, y, item, id

	for x = 1, board_tiles_x do
		for y = 1, board_tiles_y do
			for item = 1, 4 do
				id = board_data[x][y][1][item]
				if id ~= 0 then
					msg.post(id, "delete")
				end
			end
		end
	end

	board_data = {}
	timer.delay(.1, false, function()
		prepare_board()
	end)
end
